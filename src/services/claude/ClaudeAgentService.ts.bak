/**
 * ClaudeAgentService - Claude Agent æ ¸å¿ƒç¼–æ’æœåŠ¡
 *
 * èŒè´£ï¼š
 * 1. ç®¡ç†å¤šä¸ª Claude ä¼šè¯ï¼ˆchannelsï¼‰
 * 2. æ¥æ”¶å’Œåˆ†å‘æ¥è‡ª Transport çš„æ¶ˆæ¯
 * 3. å¯åŠ¨å’Œæ§åˆ¶ Claude ä¼šè¯ï¼ˆlaunchClaude, interruptClaudeï¼‰
 * 4. è·¯ç”±è¯·æ±‚åˆ°å¯¹åº”çš„ handlers
 * 5. RPC è¯·æ±‚-å“åº”ç®¡ç†
 *
 * ä¾èµ–ï¼š
 * - IClaudeSdkService: SDK è°ƒç”¨
 * - IClaudeSessionService: ä¼šè¯å†å²
 * - ILogService: æ—¥å¿—
 * - å…¶ä»–åŸºç¡€æœåŠ¡
 */

import * as vscode from 'vscode';
import { createDecorator } from '../../di/instantiation';
import { ILogService } from '../logService';
import { IConfigurationService } from '../configurationService';
import { IWorkspaceService } from '../workspaceService';
import { IFileSystemService } from '../fileSystemService';
import { INotificationService } from '../notificationService';
import { ITerminalService } from '../terminalService';
import { ISSHService } from '../sshService';
import { ITabsAndEditorsService } from '../tabsAndEditorsService';
import { IClaudeSessionService } from './ClaudeSessionService';
import { AsyncStream, ITransport } from './transport';
import { HandlerContext } from './handlers/types';
import { IWebViewService } from '../webViewService';
import { IClaudeConfigService } from '../claudeConfigService';
import { LocalTodoService } from '../LocalTodoService';
import { AutoTaskService, Task } from '../AutoTaskService';
import { FileSnapshotService } from '../FileSnapshotService';
import { WorkspaceInitService } from '../WorkspaceInitService';

// æ–° AI æœåŠ¡ï¼ˆè‡ªå»ºå·¥å…·å±‚ï¼‰
import { IAgentCoordinator, AgentCoordinator, SessionState, AgentStreamEvent, AgentConfig } from '../agent/AgentCoordinator';
import { IClaudeApiClient } from '../ai/ClaudeApiClient';
import { IToolRegistry } from '../../tools';

// æ¶ˆæ¯ç±»å‹å¯¼å…¥
import type {
    WebViewToExtensionMessage,
    ExtensionToWebViewMessage,
    RequestMessage,
    ResponseMessage,
    ExtensionRequest,
    ToolPermissionRequest,
    ToolPermissionResponse,
} from '../../shared/messages';

// SDK ç±»å‹å®šä¹‰ï¼ˆæœ¬åœ°å®šä¹‰ï¼Œä¸å†ä¾èµ– SDKï¼‰
type SDKMessage = any;
type SDKUserMessage = { type: 'user'; message: string };
type PermissionResult = { behavior: 'allow' | 'deny'; updatedInput?: unknown; updatedPermissions?: unknown[] };
type PermissionMode = string;

// Handlers å¯¼å…¥
import {
    handleInit,
    handleGetClaudeState,
    handleGetMcpServers,
    handleGetAssetUris,
    handleOpenFile,
    handleGetCurrentSelection,
    handleShowNotification,
    handleNewConversationTab,
    handleRenameTab,
    handleOpenDiff,
    handleListSessions,
    handleGetSession,
    handleExec,
    handleListFiles,
    handleStatPath,
    handleOpenContent,
    handleOpenURL,
    handleOpenConfigFile,
    handleWriteFile,
    handleGetClaudeConfig,
    handleSetApiKey,
    handleSetBaseUrl,
    handleGetSubscription,
    handleGetUsage,
    // Local Todo handlers
    handleGetLocalTodos,
    handleAddLocalTodo,
    handleUpdateLocalTodo,
    handleDeleteLocalTodo,
    handleClearCompletedTodos,
    handleImportClaudeTodos,
    // handleOpenClaudeInTerminal,
    // handleGetAuthStatus,
    // handleLogin,
    // handleSubmitOAuthCode,
} from './handlers/handlers';

// SSH Handlers å¯¼å…¥
import {
    handleSSHConnect,
    handleSSHCommand,
    handleSSHDisconnect,
    handleSSHGetOutput,
    handleSSHListSessions,
} from './handlers/sshHandlers';

/**
 * æ¨¡å‹åç§°æ˜ å°„è¡¨
 *
 * å°† UI ä¸­çš„ç®€çŸ­æ¨¡å‹ ID æ˜ å°„ä¸º Anthropic API å…¼å®¹çš„å®Œæ•´æ¨¡å‹ ID
 */
const MODEL_NAME_MAPPING: Record<string, string> = {
    // UI æ¨¡å‹ ID -> Anthropic API å®Œæ•´æ¨¡å‹ ID
    'claude-opus-4-5': 'claude-opus-4-5-20251101',
    'claude-sonnet-4-5': 'claude-sonnet-4-5-20250929',
    'claude-haiku-4-5': 'claude-haiku-4-5-20251001',
};

export const IClaudeAgentService = createDecorator<IClaudeAgentService>('claudeAgentService');

// ============================================================================
// ç±»å‹å®šä¹‰
// ============================================================================

/**
 * Channel å¯¹è±¡ï¼šç®¡ç†å•ä¸ª Claude ä¼šè¯
 * 
 * æ³¨æ„ï¼šç°åœ¨ä½¿ç”¨ AgentCoordinatorï¼Œä¸å†ä¾èµ– SDK çš„ Query å¯¹è±¡
 */
export interface Channel {
    in: AsyncStream<SDKUserMessage>;  // è¾“å…¥æµï¼šå‘ SDK å‘é€ç”¨æˆ·æ¶ˆæ¯ï¼ˆå…¼å®¹æ—§ä»£ç ï¼‰
    session?: SessionState;           // æ–°ä¼šè¯çŠ¶æ€ï¼ˆAgentCoordinatorï¼‰
    abortController?: AbortController; // ç”¨äºä¸­æ–­
}

/**
 * è¯·æ±‚å¤„ç†å™¨
 */
interface RequestHandler {
    resolve: (value: any) => void;
    reject: (error: Error) => void;
}

/**
 * Claude Agent æœåŠ¡æ¥å£
 */
export interface IClaudeAgentService {
    readonly _serviceBrand: undefined;

    /**
     * è®¾ç½® Transport
     */
    setTransport(transport: ITransport): void;

    /**
     * å¯åŠ¨æ¶ˆæ¯å¾ªç¯
     */
    start(): void;

    /**
     * æ¥æ”¶æ¥è‡ªå®¢æˆ·ç«¯çš„æ¶ˆæ¯
     */
    fromClient(message: WebViewToExtensionMessage): Promise<void>;

    /**
     * å¯åŠ¨ Claude ä¼šè¯
     */
    launchClaude(
        channelId: string,
        resume: string | null,
        cwd: string,
        model: string | null,
        permissionMode: string,
        thinkingLevel: string | null
    ): Promise<void>;

    /**
     * ä¸­æ–­ Claude ä¼šè¯
     */
    interruptClaude(channelId: string): Promise<void>;

    /**
     * å…³é—­ä¼šè¯
     */
    closeChannel(channelId: string, sendNotification: boolean, error?: string): void;

    /**
     * å…³é—­æ‰€æœ‰ä¼šè¯
     */
    closeAllChannels(): Promise<void>;

    /**
     * å‡­è¯å˜æ›´æ—¶å…³é—­æ‰€æœ‰é€šé“
     */
    closeAllChannelsWithCredentialChange(): Promise<void>;

    /**
     * å¤„ç†è¯·æ±‚
     */
    processRequest(request: RequestMessage, signal: AbortSignal): Promise<unknown>;

    /**
     * è®¾ç½®æƒé™æ¨¡å¼
     */
    setPermissionMode(channelId: string, mode: PermissionMode): Promise<void>;

    /**
     * è®¾ç½® Thinking Level
     */
    setThinkingLevel(channelId: string, level: string): Promise<void>;

    /**
     * è®¾ç½®æ¨¡å‹
     */
    setModel(channelId: string, model: string): Promise<void>;

    /**
     * é€šçŸ¥å·¥ä½œåŒºå˜åŒ–
     */
    notifyWorkspaceChanged(): void;

    /**
     * å…³é—­
     */
    shutdown(): Promise<void>;
}

// ============================================================================
// ClaudeAgentService å®ç°
// ============================================================================

/**
 * Claude Agent æœåŠ¡å®ç°
 */
export class ClaudeAgentService implements IClaudeAgentService {
    readonly _serviceBrand: undefined;

    // Transport é€‚é…å™¨
    private transport?: ITransport;

    // ä¼šè¯ç®¡ç†
    private channels = new Map<string, Channel>();

    // æ¥æ”¶æ¥è‡ªå®¢æˆ·ç«¯çš„æ¶ˆæ¯æµ
    private fromClientStream = new AsyncStream<WebViewToExtensionMessage>();

    // ç­‰å¾…å“åº”çš„è¯·æ±‚
    private outstandingRequests = new Map<string, RequestHandler>();

    // å–æ¶ˆæ§åˆ¶å™¨
    private abortControllers = new Map<string, AbortController>();

    // Handler ä¸Šä¸‹æ–‡ï¼ˆç¼“å­˜ï¼‰
    private handlerContext: HandlerContext;

    // Thinking Level é…ç½®
    private thinkingLevel: string = 'off';

    // æ¯ä¸ª channel çš„æƒé™æ¨¡å¼ï¼ˆç”¨äº YOLO æ¨¡å¼åˆ¤æ–­ï¼‰
    private channelPermissionModes = new Map<string, string>();

    // æ¯ä¸ª channel çš„ session IDï¼ˆç”¨äºé”™è¯¯æ¢å¤ï¼‰
    private channelSessionIds = new Map<string, string>();

    // æ¯ä¸ª channel çš„å¯åŠ¨å‚æ•°ï¼ˆç”¨äºé”™è¯¯æ¢å¤æ—¶é‡æ–°å¯åŠ¨ï¼‰
    private channelLaunchParams = new Map<string, {
        cwd: string;
        model: string | null;
        permissionMode: string;
        thinkingLevel: string | null;
    }>();

    // InputValidationError é‡è¯•è®¡æ•°ï¼ˆé˜²æ­¢æ— é™é‡è¯•ï¼‰
    private channelRetryCount = new Map<string, number>();
    private readonly MAX_RETRY_COUNT = 2;

    // è‡ªåŠ¨å®¡æ‰¹é…ç½®
    private autoApproveConfig = {
        autoApproveEnabled: true,  // æ€»å¼€å…³ï¼šé»˜è®¤å¯ç”¨
        confirmWrite: true,   // Write å·¥å…·é»˜è®¤éœ€è¦ç¡®è®¤
        confirmEdit: true     // Edit å·¥å…·é»˜è®¤éœ€è¦ç¡®è®¤
    };

    // è‡ªåŠ¨ä»»åŠ¡æœåŠ¡
    private autoTaskService: AutoTaskService;

    constructor(
        // é™æ€å‚æ•°å¿…é¡»æ”¾åœ¨æœ€å‰é¢ï¼ˆç”± SyncDescriptor ä¼ å…¥ï¼‰
        private readonly localTodoService: LocalTodoService,
        // æœåŠ¡æ³¨å…¥å‚æ•°
        @ILogService private readonly logService: ILogService,
        @IConfigurationService private readonly configService: IConfigurationService,
        @IWorkspaceService private readonly workspaceService: IWorkspaceService,
        @IFileSystemService private readonly fileSystemService: IFileSystemService,
        @INotificationService private readonly notificationService: INotificationService,
        @ITerminalService private readonly terminalService: ITerminalService,
        @ISSHService private readonly sshService: ISSHService,
        @ITabsAndEditorsService private readonly tabsAndEditorsService: ITabsAndEditorsService,
        @IClaudeSessionService private readonly sessionService: IClaudeSessionService,
        @IWebViewService private readonly webViewService: IWebViewService,
        @IClaudeConfigService private readonly claudeConfigService: IClaudeConfigService,
        // æ–° AI æœåŠ¡
        @IAgentCoordinator private readonly agentCoordinator: IAgentCoordinator,
        @IClaudeApiClient private readonly claudeApiClient: IClaudeApiClient,
        @IToolRegistry private readonly toolRegistry: IToolRegistry
    ) {
        // æ„å»º Handler ä¸Šä¸‹æ–‡
        this.handlerContext = {
            logService: this.logService,
            configService: this.configService,
            workspaceService: this.workspaceService,
            fileSystemService: this.fileSystemService,
            notificationService: this.notificationService,
            terminalService: this.terminalService,
            sshService: this.sshService,
            tabsAndEditorsService: this.tabsAndEditorsService,
            sessionService: this.sessionService,
            agentService: this,  // è‡ªèº«å¼•ç”¨
            webViewService: this.webViewService,
            claudeConfigService: this.claudeConfigService,
            localTodoService: this.localTodoService,
            claudeApiClient: this.claudeApiClient,
        };

        // åˆå§‹åŒ–è‡ªåŠ¨ä»»åŠ¡æœåŠ¡
        this.autoTaskService = new AutoTaskService(this.logService, this);

        // è®¾ç½®ä»»åŠ¡å‘ç°å›è°ƒï¼ˆç”¨äºè‡ªåŠ¨æ‰§è¡Œï¼‰
        this.autoTaskService.onTaskFound((tasks) => {
            this.handleAutoTaskFound(tasks);
        });

        // è®¾ç½®æ–‡ä»¶å˜åŒ–å›è°ƒï¼ˆç”¨äºå®æ—¶ UI æ›´æ–°ï¼‰
        this.autoTaskService.onTaskFileChanged((tasks) => {
            this.handleTaskFileChanged(tasks);
        });
    }

    /**
     * è®¾ç½® Transport
     */
    setTransport(transport: ITransport): void {
        this.transport = transport;

        // ç›‘å¬æ¥è‡ªå®¢æˆ·ç«¯çš„æ¶ˆæ¯ï¼Œæ¨å…¥é˜Ÿåˆ—
        transport.onMessage(async (message) => {
            await this.fromClient(message);
        });

        this.logService.info('[ClaudeAgentService] Transport å·²è¿æ¥');
    }

    /**
     * å¯åŠ¨æ¶ˆæ¯å¾ªç¯
     */
    start(): void {
        // å¯åŠ¨æ¶ˆæ¯å¾ªç¯
        this.readFromClient();

        this.logService.info('[ClaudeAgentService] æ¶ˆæ¯å¾ªç¯å·²å¯åŠ¨');
    }

    /**
     * æ¥æ”¶æ¥è‡ªå®¢æˆ·ç«¯çš„æ¶ˆæ¯
     */
    async fromClient(message: WebViewToExtensionMessage): Promise<void> {
        this.fromClientStream.enqueue(message);
    }

    /**
     * ä»å®¢æˆ·ç«¯è¯»å–å¹¶åˆ†å‘æ¶ˆæ¯
     */
    private async readFromClient(): Promise<void> {
        try {
            for await (const message of this.fromClientStream) {
                try {
                    switch (message.type) {
                        case "launch_claude":
                            await this.launchClaude(
                                message.channelId,
                                message.resume || null,
                                message.cwd || this.getCwd(),
                                message.model || null,
                                message.permissionMode || "acceptEdits",
                                message.thinkingLevel || null
                            );
                            break;

                        case "close_channel":
                            this.closeChannel(message.channelId, false);
                            break;

                        case "interrupt_claude":
                            await this.interruptClaude(message.channelId);
                            break;

                        case "io_message":
                            this.transportMessage(
                                message.channelId,
                                message.message,
                                message.done
                            );
                            break;

                        case "request":
                            this.handleRequest(message);
                            break;

                        case "response":
                            this.handleResponse(message);
                            break;

                        case "cancel_request":
                            this.handleCancellation(message.targetRequestId);
                            break;

                        default:
                            this.logService.error(`Unknown message type: ${(message as { type: string }).type}`);
                    }
                } catch (messageError) {
                    // å•ä¸ªæ¶ˆæ¯å¤„ç†å¤±è´¥ä¸åº”è¯¥ä¸­æ–­æ•´ä¸ªæ¶ˆæ¯å¾ªç¯
                    this.logService.error(`[ClaudeAgentService] å¤„ç†æ¶ˆæ¯æ—¶å‡ºé”™ (${message.type}): ${messageError}`);
                }
            }
        } catch (error) {
            this.logService.error(`[ClaudeAgentService] Error in readFromClient: ${error}`);
        }
    }

    /**
     * å¯åŠ¨ Claude ä¼šè¯
     */
    async launchClaude(
        channelId: string,
        resume: string | null,
        cwd: string,
        model: string | null,
        permissionMode: string,
        thinkingLevel: string | null
    ): Promise<void> {
        // ä¿å­˜ thinkingLevel
        if (thinkingLevel) {
            this.thinkingLevel = thinkingLevel;
        }

        // ä½¿ç”¨æ–°æ¶æ„ï¼ˆè‡ªå»ºå·¥å…·å±‚ï¼‰
        await this.launchClaudeNewArch(channelId, cwd, model, permissionMode);
    }

    /**
     * ä½¿ç”¨æ–°æ¶æ„å¯åŠ¨ Claude ä¼šè¯ï¼ˆè‡ªå»ºå·¥å…·å±‚ï¼‰
     */
    private async launchClaudeNewArch(
        channelId: string,
        cwd: string,
        model: string | null,
        permissionMode: string
    ): Promise<void> {
        this.logService.info('');
        this.logService.info('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        this.logService.info('â•‘  å¯åŠ¨ Claude ä¼šè¯ï¼ˆæ–°æ¶æ„ï¼‰              â•‘');
        this.logService.info('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        this.logService.info(`  Channel ID: ${channelId}`);
        this.logService.info(`  CWD: ${cwd}`);
        this.logService.info(`  Model: ${model || 'default'}`);
        this.logService.info(`  Permission: ${permissionMode}`);
        this.logService.info('');

        // ğŸ”„ æ–°ä¼šè¯å¼€å§‹æ—¶æ¸…ç†ä»»åŠ¡æ–‡ä»¶ï¼ˆåªä¿ç•™å¾…åŠä»»åŠ¡ï¼‰
        try {
            const workspaceInitService = new WorkspaceInitService({
                info: (msg: string) => this.logService.info(msg),
                error: (msg: string, err?: unknown) => this.logService.error(msg, err)
            });
            await workspaceInitService.cleanupTasksFile(cwd);
        } catch (cleanupError) {
            // æ¸…ç†å¤±è´¥ä¸å½±å“ä¼šè¯å¯åŠ¨
            this.logService.error('[ClaudeAgentService] ä»»åŠ¡æ¸…ç†å¤±è´¥', cleanupError);
        }

        // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        if (this.channels.has(channelId)) {
            this.logService.error(`âŒ Channel å·²å­˜åœ¨: ${channelId}`);
            throw new Error(`Channel already exists: ${channelId}`);
        }

        try {
            // 1. é…ç½® ClaudeApiClientï¼ˆå¦‚æœå°šæœªé…ç½®ï¼‰
            if (!this.claudeApiClient.isConfigured()) {
                // ä» ClaudeConfigService è·å– API Keyã€Base URL å’Œ Model
                const apiKey = await this.claudeConfigService.getApiKey();
                const baseUrl = await this.claudeConfigService.getBaseUrl();
                const configuredModel = await this.claudeConfigService.getModel();

                this.logService.info(`[ClaudeAgentService] é…ç½®ä¿¡æ¯: baseUrl=${baseUrl}, hasApiKey=${!!apiKey}, configuredModel=${configuredModel}`);

                if (!apiKey) {
                    // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„æç¤ºï¼ˆä¸é˜»å¡æ¶ˆæ¯å¾ªç¯ï¼‰
                    const errorMessage = 'âŒ API Key æœªé…ç½®\n\nè¯·æŒ‰ä»¥ä¸‹æ­¥éª¤é…ç½®ï¼š\n1. ç‚¹å‡»ä¸‹æ–¹ "é…ç½® API Key" æŒ‰é’®\n2. æˆ–åœ¨è®¾ç½®ä¸­æœç´¢ "xiong.apiKey" è¿›è¡Œé…ç½®\n3. é…ç½®å®Œæˆåé‡æ–°å¯åŠ¨èŠå¤©';

                    this.notificationService.showError(errorMessage);

                    // å¼‚æ­¥æ˜¾ç¤ºå¯¹è¯æ¡†ï¼Œä¸é˜»å¡æ¶ˆæ¯å¾ªç¯
                    vscode.window.showErrorMessage(
                        'API Key æœªé…ç½®ï¼Œæ— æ³•ä½¿ç”¨èŠå¤©åŠŸèƒ½',
                        'é…ç½® API Key',
                        'å–æ¶ˆ'
                    ).then(action => {
                        if (action === 'é…ç½® API Key') {
                            vscode.commands.executeCommand('xiong.openSettings');
                        }
                    });

                    throw new Error('API Key æœªé…ç½®ï¼Œè¯·åœ¨è®¾ç½®ä¸­é…ç½® API Key');
                }
                // ä½¿ç”¨é…ç½®çš„æ¨¡å‹ï¼Œå¦‚æœæœªé…ç½®åˆ™ä½¿ç”¨ä¼ å…¥çš„æ¨¡å‹æˆ–é»˜è®¤å€¼
                const defaultModel = configuredModel || model || 'claude-sonnet-4-5-20250929';
                this.logService.info(`[ClaudeAgentService] æœ€ç»ˆä½¿ç”¨æ¨¡å‹: ${defaultModel}`);
                this.claudeApiClient.configure({
                    baseUrl: baseUrl || 'https://api.anthropic.com',
                    apiKey: apiKey,
                    defaultModel: defaultModel,
                });
                this.logService.info(`  âœ“ ClaudeApiClient å·²é…ç½®ï¼Œæ¨¡å‹: ${defaultModel}`);
            } else {
                this.logService.info(`[ClaudeAgentService] ClaudeApiClient å·²é…ç½®ï¼Œè·³è¿‡é‡æ–°é…ç½®`);
            }

            // 2. åˆ›å»º AgentCoordinator ä¼šè¯
            // æ³¨æ„ï¼šéœ€è¦å°† UI ä¼ æ¥çš„ç®€çŸ­æ¨¡å‹åæ˜ å°„ä¸ºå®Œæ•´çš„ API æ¨¡å‹å
            let resolvedModel: string | undefined;
            if (model) {
                // å…ˆå°è¯•ä»æ˜ å°„è¡¨è·å–å®Œæ•´æ¨¡å‹å
                resolvedModel = MODEL_NAME_MAPPING[model] || model;
            } else {
                // å¦‚æœæ²¡æœ‰ä¼ å…¥æ¨¡å‹ï¼Œä»é…ç½®ä¸­è·å–
                resolvedModel = await this.claudeConfigService.getModel() || undefined;
            }
            this.logService.info(`[ClaudeAgentService] AgentConfig ä½¿ç”¨æ¨¡å‹: ${resolvedModel || '(ä½¿ç”¨ API é»˜è®¤)'}`);

            const agentConfig: AgentConfig = {
                model: resolvedModel,
                cwd,
                impersonateClaude: true, // å§‹ç»ˆå¯ç”¨ Claude ä¼ªè£…ï¼Œé˜²æ­¢æ¨¡å‹æš´éœ²çœŸå®èº«ä»½
                maxToolLoops: 1000, // å¢åŠ åˆ° 1000 æ¬¡ï¼Œæ”¯æŒæ›´å¤æ‚çš„ä»»åŠ¡
            };

            const session = this.agentCoordinator.createSession(agentConfig);
            this.logService.info(`  âœ“ ä¼šè¯å·²åˆ›å»º: ${session.id}`);

            // 3. åˆ›å»ºè¾“å…¥æµå’Œ AbortController
            const inputStream = new AsyncStream<SDKUserMessage>();
            const abortController = new AbortController();

            // 4. å­˜å‚¨ channel
            this.channels.set(channelId, {
                in: inputStream,
                session,
                abortController,
            });
            this.channelPermissionModes.set(channelId, permissionMode);
            this.logService.info(`  âœ“ Channel å·²æ³¨å†Œï¼Œå½“å‰ ${this.channels.size} ä¸ªæ´»è·ƒä¼šè¯`);

            // 5. å‘é€åˆå§‹åŒ–æ¶ˆæ¯ç»™ WebView
            this.transport!.send({
                type: "io_message",
                channelId,
                message: {
                    type: "assistant",
                    subtype: "init",
                    session_id: session.id,
                    cwd: cwd,
                } as any,
                done: false
            });

            // 6. å¯åŠ¨æ¶ˆæ¯ç›‘å¬å¾ªç¯
            this.startNewArchMessageLoop(channelId, inputStream, session, abortController.signal);

            this.logService.info('');
            this.logService.info('âœ“ Claude ä¼šè¯å¯åŠ¨æˆåŠŸï¼ˆæ–°æ¶æ„ï¼‰');
            this.logService.info('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            this.logService.info('');

        } catch (error) {
            this.logService.error(`âŒ ä¼šè¯å¯åŠ¨å¤±è´¥: ${error}`);

            // å‘é€å‹å¥½çš„é”™è¯¯æ¶ˆæ¯åˆ°å‰ç«¯
            if (this.transport) {
                const errorMessages: Record<string, string> = {
                    'API Key æœªé…ç½®ï¼Œè¯·åœ¨è®¾ç½®ä¸­é…ç½® API Key': 'âš ï¸ API Key æœªé…ç½®\n\nè¯·åœ¨è®¾ç½®é¡µé¢é…ç½® API Key åé‡è¯•ã€‚\n\næ­¥éª¤ï¼š\n1. ç‚¹å‡»å³ä¸Šè§’è®¾ç½®å›¾æ ‡ âš™ï¸\n2. å¡«å†™ "API Key" å­—æ®µ\n3. ç‚¹å‡» "ä¿å­˜é…ç½®"'
                };

                const friendlyMessage = errorMessages[String(error)] ||
                    `âš ï¸ å¯åŠ¨å¤±è´¥ï¼š${error}\n\nå¦‚æœé—®é¢˜æŒç»­å­˜åœ¨ï¼Œè¯·æ£€æŸ¥ï¼š\nâ€¢ API Key æ˜¯å¦æ­£ç¡®é…ç½®\nâ€¢ ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸\nâ€¢ Base URL æ˜¯å¦å¯è®¿é—®`;

                this.transport.send({
                    type: "io_message",
                    channelId,
                    message: {
                        type: 'system',
                        message: {
                            type: 'error',
                            content: friendlyMessage
                        }
                    } as any,
                    done: true
                });
            }

            this.closeChannel(channelId, true, String(error));
            throw error;
        }
    }

    /**
     * æ–°æ¶æ„æ¶ˆæ¯å¾ªç¯
     * 
     * æµå¼è¾“å‡ºç­–ç•¥ï¼š
     * - ç´¯ç§¯æ–‡æœ¬å†…å®¹ï¼Œåªåœ¨å®Œæˆæ—¶å‘é€å®Œæ•´æ¶ˆæ¯
     * - å·¥å…·è°ƒç”¨æ—¶ï¼Œå‘é€åŒ…å« tool_use çš„ assistant æ¶ˆæ¯
     * - å·¥å…·ç»“æœä½œä¸ºå•ç‹¬çš„ user æ¶ˆæ¯å‘é€
     */
    private async startNewArchMessageLoop(
        channelId: string,
        inputStream: AsyncStream<SDKUserMessage>,
        session: SessionState,
        signal: AbortSignal
    ): Promise<void> {
        (async () => {
            try {
                for await (const userMessage of inputStream) {
                    if (signal.aborted) {
                        break;
                    }

                    // åªå¤„ç†ç”¨æˆ·æ–‡æœ¬æ¶ˆæ¯
                    if (userMessage.type !== 'user') {
                        continue;
                    }

                    // SDK æ¶ˆæ¯æ ¼å¼ï¼š{ type, message: { role, content } }
                    const messageContent = (userMessage as any).message?.content ?? userMessage.content;

                    // ä¿ç•™å®Œæ•´çš„å†…å®¹å—ï¼ˆåŒ…æ‹¬å›¾ç‰‡ï¼‰ï¼Œä¸è¦è½¬æ¢ä¸ºçº¯å­—ç¬¦ä¸²
                    const content = typeof messageContent === 'string'
                        ? messageContent
                        : messageContent;  // âœ… ç›´æ¥ä½¿ç”¨å†…å®¹å—æ•°ç»„ï¼ŒåŒ…å«å›¾ç‰‡

                    this.logService.info(`[NewArch] æ”¶åˆ°ç”¨æˆ·æ¶ˆæ¯: ${content.slice(0, 100)}...`);

                    // ä½¿ç”¨ AgentCoordinator å¤„ç†æ¶ˆæ¯
                    try {
                        // ç´¯ç§¯å†…å®¹
                        let accumulatedText = '';
                        let currentToolId = '';
                        let eventCount = 0;

                        this.logService.info(`[NewArch] å¼€å§‹å¤„ç†æµå¼æ¶ˆæ¯...`);

                        // åˆ›å»ºå·¥å…·ç¡®è®¤å›è°ƒ
                        const toolConfirmCallback = async (toolName: string, toolId: string, input: any): Promise<boolean> => {
                            if (this.shouldConfirmTool(toolName)) {
                                this.logService.info(`[NewArch] å·¥å…· ${toolName} (id=${toolId}) éœ€è¦ç”¨æˆ·ç¡®è®¤`);

                                // ä½¿ç”¨ WebView å†…è”æƒé™è¯·æ±‚ï¼ˆè½»é‡çº§ UIï¼‰
                                try {
                                    const result = await this.requestToolPermission(
                                        channelId,
                                        toolName,
                                        input,
                                        [] // ä¸æä¾›æƒé™æ›´æ–°å»ºè®®
                                    );

                                    const confirmed = result.behavior === 'allow';
                                    this.logService.info(`[NewArch] ç”¨æˆ·é€‰æ‹©: ${confirmed ? 'å…è®¸' : 'æ‹’ç»'}`);
                                    return confirmed;
                                } catch (error) {
                                    this.logService.error(`[NewArch] æƒé™è¯·æ±‚å¤±è´¥: ${error}`);
                                    return false;
                                }
                            }
                            return true;
                        };

                        for await (const event of this.agentCoordinator.streamMessage(session, content, { signal, toolConfirmCallback })) {
                            eventCount++;
                            this.logService.debug(`[NewArch] æ”¶åˆ°äº‹ä»¶ #${eventCount}: ${event.type}`);

                            if (signal.aborted) {
                                this.logService.info(`[NewArch] æ”¶åˆ°ä¸­æ­¢ä¿¡å·ï¼Œåœæ­¢å¤„ç†`);
                                break;
                            }

                            switch (event.type) {
                                case 'text':
                                    // åªç´¯ç§¯æ–‡æœ¬ï¼Œä¸ç«‹å³å‘é€
                                    accumulatedText += event.text;
                                    break;

                                case 'tool_start':
                                    this.logService.info(`[NewArch] å·¥å…·å¼€å§‹: ${event.name} (id=${event.id})`);
                                    // ä½¿ç”¨ AgentCoordinator ä¼ é€’çš„å·¥å…· ID
                                    currentToolId = event.id;

                                    // å‘é€åŒ…å«ä¹‹å‰æ–‡æœ¬å’Œ tool_use çš„ assistant æ¶ˆæ¯
                                    {
                                        const contentBlocks: any[] = [];
                                        if (accumulatedText) {
                                            contentBlocks.push({ type: 'text', text: accumulatedText });
                                            accumulatedText = ''; // æ¸…ç©ºå·²å‘é€çš„æ–‡æœ¬
                                        }
                                        contentBlocks.push({
                                            type: 'tool_use',
                                            id: currentToolId,
                                            name: event.name,
                                            input: event.input,
                                        });

                                        this.transport!.send({
                                            type: "io_message",
                                            channelId,
                                            message: {
                                                type: 'assistant',
                                                message: {
                                                    role: 'assistant',
                                                    content: contentBlocks,
                                                },
                                                session_id: session.id,
                                            } as any,
                                            done: false
                                        });
                                    }
                                    break;

                                case 'tool_end':
                                    this.logService.info(`[NewArch] å·¥å…·ç»“æŸ: ${event.name} (id=${event.id}, isError=${event.isError}, snapshotId=${event.snapshotId}, canRevert=${event.canRevert})`);
                                    // ä½¿ç”¨äº‹ä»¶ä¸­çš„ IDï¼ˆä¸ tool_start ä¸€è‡´ï¼‰
                                    this.transport!.send({
                                        type: "io_message",
                                        channelId,
                                        message: {
                                            type: 'user',
                                            message: {
                                                role: 'user',
                                                content: [{
                                                    type: 'tool_result',
                                                    tool_use_id: event.id,
                                                    content: event.output,
                                                    is_error: event.isError,
                                                    // ä¼ é€’æ’¤å›ç›¸å…³å­—æ®µåˆ°å‰ç«¯
                                                    snapshotId: event.snapshotId,
                                                    canRevert: event.canRevert,
                                                }],
                                            },
                                            session_id: session.id,
                                        } as any,
                                        done: false
                                    });
                                    break;

                                case 'thinking':
                                    // thinking æš‚æ—¶å¿½ç•¥æˆ–å•ç‹¬å¤„ç†
                                    break;

                                case 'done':
                                    this.logService.info(`[NewArch] æµå¤„ç†å®Œæˆï¼Œç´¯è®¡äº‹ä»¶: ${eventCount}`);
                                    this.logService.info(`[NewArch] æœ€ç»ˆç´¯ç§¯æ–‡æœ¬é•¿åº¦: ${accumulatedText.length} å­—ç¬¦`);

                                    // å®Œæˆï¼šå‘é€æœ€ç»ˆçš„æ–‡æœ¬æ¶ˆæ¯ï¼ˆå¦‚æœæœ‰ï¼‰
                                    if (accumulatedText) {
                                        this.transport!.send({
                                            type: "io_message",
                                            channelId,
                                            message: {
                                                type: 'assistant',
                                                message: {
                                                    role: 'assistant',
                                                    content: [{ type: 'text', text: accumulatedText }],
                                                },
                                                session_id: session.id,
                                            } as any,
                                            done: false
                                        });
                                        this.logService.info(`[NewArch] å·²å‘é€æœ€ç»ˆæ–‡æœ¬æ¶ˆæ¯`);
                                    }

                                    // å‘é€ result æ¶ˆæ¯
                                    this.transport!.send({
                                        type: "io_message",
                                        channelId,
                                        message: {
                                            type: 'result',
                                            subtype: 'success',
                                            session_id: session.id,
                                            cost_usd: 0,
                                            usage: event.usage || { inputTokens: 0, outputTokens: 0 },
                                        } as any,
                                        done: false
                                    });
                                    this.logService.info(`[NewArch] å·²å‘é€ result æ¶ˆæ¯ï¼Œä»»åŠ¡å®Œæˆ`);
                                    break;

                                case 'error':
                                    this.logService.error(`[NewArch] AgentCoordinator è¿”å›é”™è¯¯: ${event.error}`);

                                    // å‘é€é”™è¯¯æ¶ˆæ¯åˆ° UI
                                    this.transport!.send({
                                        type: "io_message",
                                        channelId,
                                        message: {
                                            type: 'result',
                                            subtype: 'error',
                                            session_id: session.id,
                                            error: event.error,
                                        } as any,
                                        done: false
                                    });

                                    // åŒæ—¶å‘é€é€šçŸ¥è®©ç”¨æˆ·çŸ¥é“å‡ºé”™äº†ï¼Œä½†å¼ºè°ƒå¯ä»¥ç»§ç»­ä½¿ç”¨
                                    this.notificationService.showWarning(`âš ï¸ è¯·æ±‚é‡åˆ°é—®é¢˜: ${event.error}\n\næ‚¨å¯ä»¥ç»§ç»­å‘é€æ¶ˆæ¯ã€‚`);
                                    this.logService.error(`[NewArch] å·²å‘é€é”™è¯¯é€šçŸ¥åˆ° UI`);
                                    break;
                            }

                            // å¦‚æœæ˜¯å®Œæˆæˆ–é”™è¯¯äº‹ä»¶ï¼Œè·³å‡ºå†…å±‚å¾ªç¯
                            if (event.type === 'done' || event.type === 'error') {
                                this.logService.info(`[NewArch] æ”¶åˆ°ç»ˆæ­¢äº‹ä»¶: ${event.type}ï¼Œè·³å‡ºæµå¤„ç†å¾ªç¯`);
                                break;
                            }
                        }

                        this.logService.info(`[NewArch] æ¶ˆæ¯å¤„ç†å®Œæˆï¼Œç­‰å¾…ä¸‹ä¸€æ¡ç”¨æˆ·æ¶ˆæ¯`);
                    } catch (streamError) {
                        this.logService.error(`[NewArch] æµå¼å¤„ç†é”™è¯¯: ${streamError}`);

                        // å‘é€é”™è¯¯æ¶ˆæ¯åˆ° UI
                        this.transport!.send({
                            type: "io_message",
                            channelId,
                            message: {
                                type: "error",
                                error: String(streamError),
                                session_id: session.id,
                            } as any,
                            done: false
                        });

                        // å‘é€ result é”™è¯¯æ¶ˆæ¯
                        this.transport!.send({
                            type: "io_message",
                            channelId,
                            message: {
                                type: 'result',
                                subtype: 'error',
                                session_id: session.id,
                                error: String(streamError),
                            } as any,
                            done: false
                        });

                        // é€šçŸ¥ç”¨æˆ·ï¼Œä½†å¼ºè°ƒå¯ä»¥ç»§ç»­ä½¿ç”¨
                        this.notificationService.showWarning(`âš ï¸ è¯·æ±‚é‡åˆ°é—®é¢˜: ${streamError}\n\næ‚¨å¯ä»¥ç»§ç»­å‘é€æ¶ˆæ¯ã€‚`);
                        this.logService.info(`[NewArch] å·²å‘é€ result é”™è¯¯æ¶ˆæ¯ï¼Œç”¨æˆ·å¯ä»¥ç»§ç»­å‘é€æ–°æ¶ˆæ¯`);
                    }
                }

                // æ­£å¸¸ç»“æŸ
                this.logService.info(`[NewArch] æ¶ˆæ¯å¾ªç¯ç»“æŸ`);
                this.closeChannel(channelId, true);

            } catch (error) {
                this.logService.error(`[NewArch] æ¶ˆæ¯å¾ªç¯é”™è¯¯: ${error}`);
                this.closeChannel(channelId, true, String(error));
            }
        })();
    }

    /**
     * å°† AgentStreamEvent è½¬æ¢ä¸º SDK æ¶ˆæ¯æ ¼å¼ï¼ˆå…¼å®¹ WebViewï¼‰
     * 
     * WebView çš„ Message.fromRaw æœŸæœ›æ ¼å¼ï¼š
     * - raw.type: 'user' | 'assistant'
     * - raw.message.content: ContentBlock[] (æ•°ç»„)
     */
    private convertAgentEventToSdkMessage(event: AgentStreamEvent, sessionId: string): SDKMessage | null {
        switch (event.type) {
            case 'text':
                return {
                    type: 'assistant',
                    message: {
                        role: 'assistant',
                        content: [{ type: 'text', text: event.text }],
                    },
                    session_id: sessionId,
                } as any;

            case 'tool_start':
                return {
                    type: 'assistant',
                    message: {
                        role: 'assistant',
                        content: [{
                            type: 'tool_use',
                            id: `tool_${Date.now()}`,
                            name: event.name,
                            input: event.input,
                        }],
                    },
                    session_id: sessionId,
                } as any;

            case 'tool_end':
                return {
                    type: 'user',
                    message: {
                        role: 'user',
                        content: [{
                            type: 'tool_result',
                            tool_use_id: `tool_${Date.now()}`,
                            content: event.output,
                            is_error: event.isError,
                        }],
                    },
                    session_id: sessionId,
                } as any;

            case 'thinking':
                return {
                    type: 'assistant',
                    message: {
                        role: 'assistant',
                        content: [{ type: 'thinking', thinking: event.text }],
                    },
                    session_id: sessionId,
                } as any;

            case 'done':
                return {
                    type: 'result',
                    subtype: 'success',
                    session_id: sessionId,
                    cost_usd: 0,
                    usage: event.usage || { inputTokens: 0, outputTokens: 0 },
                } as any;

            case 'error':
                return {
                    type: 'result',
                    subtype: 'error',
                    session_id: sessionId,
                    error: event.error,
                } as any;

            default:
                return null;
        }
    }

    /**
     * ä¸­æ–­ Claude ä¼šè¯
     */
    async interruptClaude(channelId: string): Promise<void> {
        const channel = this.channels.get(channelId);
        if (!channel) {
            this.logService.warn(`[ClaudeAgentService] Channel ä¸å­˜åœ¨: ${channelId}`);
            return;
        }

        try {
            // ä½¿ç”¨ AbortController ä¸­æ–­
            if (channel.abortController) {
                channel.abortController.abort();
                this.logService.info(`[ClaudeAgentService] å·²ä¸­æ–­ Channel: ${channelId}`);

                // å‘é€ä¸­æ–­æ¶ˆæ¯ç»™å‰ç«¯
                if (this.transport) {
                    // 1. å‘é€ interrupt ç±»å‹çš„æ¶ˆæ¯ï¼ˆæ˜¾ç¤ºä¸­æ–­æ–‡æœ¬ï¼‰
                    this.transport.send({
                        type: "io_message",
                        channelId,
                        message: {
                            type: 'interrupt',
                            message: {
                                reason: 'user_interrupt',
                                text: '[Request interrupted by user]',
                            },
                        } as any,
                        done: false
                    });

                    // 2. å‘é€ result ç±»å‹çš„æ¶ˆæ¯ï¼Œè®©å‰ç«¯è§£é™¤ busy çŠ¶æ€
                    this.transport.send({
                        type: "io_message",
                        channelId,
                        message: {
                            type: 'result',
                            interrupted: true,
                        } as any,
                        done: true  // æ ‡è®°ä¸ºå®Œæˆ
                    });

                    // 3. å‘é€ close_channel å…³é—­ streamï¼Œç¡®ä¿å‰ç«¯ readMessages å¾ªç¯æ­£ç¡®é€€å‡º
                    // è¿™æ ·ä¸‹æ¬¡å‘é€æ¶ˆæ¯æ—¶å¯ä»¥æ­£å¸¸åˆ›å»ºæ–°çš„ channel
                    this.transport.send({
                        type: "close_channel",
                        channelId,
                    });
                }
            }

            // 4. æ¸…ç† channel èµ„æº
            this.channels.delete(channelId);
            this.channelPermissionModes.delete(channelId);
            this.channelSessionIds.delete(channelId);
            this.channelLaunchParams.delete(channelId);
            this.channelRetryCount.delete(channelId);
            this.logService.info(`[ClaudeAgentService] Channel ${channelId} èµ„æºå·²æ¸…ç†`);
        } catch (error) {
            this.logService.error(`[ClaudeAgentService] ä¸­æ–­å¤±è´¥:`, error);
        }
    }

    /**
     * å…³é—­ä¼šè¯
     */
    closeChannel(channelId: string, sendNotification: boolean, error?: string): void {
        this.logService.info(`[ClaudeAgentService] å…³é—­ Channel: ${channelId}`);

        // 1. å‘é€å…³é—­é€šçŸ¥
        if (sendNotification && this.transport) {
            this.transport.send({
                type: "close_channel",
                channelId,
                error
            });
        }

        // 2. æ¸…ç† channel
        const channel = this.channels.get(channelId);
        if (channel) {
            channel.in.done();

            // ä½¿ç”¨ AbortController ä¸­æ–­
            if (channel.abortController) {
                channel.abortController.abort();
            }

            this.channels.delete(channelId);
        }

        // 3. æ¸…ç†æƒé™æ¨¡å¼è®°å½•
        this.channelPermissionModes.delete(channelId);

        // 4. æ¸…ç†é”™è¯¯æ¢å¤ç›¸å…³è®°å½•
        this.channelSessionIds.delete(channelId);
        this.channelLaunchParams.delete(channelId);
        this.channelRetryCount.delete(channelId);

        this.logService.info(`  âœ“ Channel å·²å…³é—­ï¼Œå‰©ä½™ ${this.channels.size} ä¸ªæ´»è·ƒä¼šè¯`);
    }


    /**
     * å…³é—­æ‰€æœ‰ä¼šè¯
     */
    async closeAllChannels(): Promise<void> {
        const promises = Array.from(this.channels.keys()).map(channelId =>
            this.closeChannel(channelId, false)
        );
        await Promise.all(promises);
        this.channels.clear();
    }

    /**
     * å‡­è¯å˜æ›´æ—¶å…³é—­æ‰€æœ‰é€šé“
     */
    async closeAllChannelsWithCredentialChange(): Promise<void> {
        const promises = Array.from(this.channels.keys()).map(channelId =>
            this.closeChannel(channelId, true)
        );
        await Promise.all(promises);
        this.channels.clear();
    }

    /**
     * ä¼ è¾“æ¶ˆæ¯åˆ° Channel
     */
    private transportMessage(
        channelId: string,
        message: SDKMessage | SDKUserMessage,
        done: boolean
    ): void {
        const channel = this.channels.get(channelId);
        if (!channel) {
            throw new Error(`Channel not found: ${channelId}`);
        }

        // ç”¨æˆ·æ¶ˆæ¯åŠ å…¥è¾“å…¥æµ
        if (message.type === "user") {
            channel.in.enqueue(message as SDKUserMessage);
        }

        // å¦‚æœæ ‡è®°ä¸ºç»“æŸï¼Œå…³é—­è¾“å…¥æµ
        if (done) {
            channel.in.done();
        }
    }

    /**
     * å¤„ç†æ¥è‡ªå®¢æˆ·ç«¯çš„è¯·æ±‚
     */
    private async handleRequest(message: RequestMessage): Promise<void> {
        const abortController = new AbortController();
        this.abortControllers.set(message.requestId, abortController);

        try {
            const response = await this.processRequest(message, abortController.signal);
            this.transport!.send({
                type: "response",
                requestId: message.requestId,
                response
            });
        } catch (error) {
            const errorMsg = error instanceof Error ? error.message : String(error);
            this.transport!.send({
                type: "response",
                requestId: message.requestId,
                response: {
                    type: "error",
                    error: errorMsg
                }
            });
        } finally {
            this.abortControllers.delete(message.requestId);
        }
    }

    /**
     * å¤„ç†è¯·æ±‚
     */
    async processRequest(message: RequestMessage, signal: AbortSignal): Promise<unknown> {
        const request = message.request;
        const channelId = message.channelId;

        if (!request || typeof request !== 'object' || !('type' in request)) {
            throw new Error('Invalid request format');
        }

        this.logService.info(`[ClaudeAgentService] å¤„ç†è¯·æ±‚: ${request.type}`);

        // è·¯ç”±è¡¨ï¼šå°†è¯·æ±‚ç±»å‹æ˜ å°„åˆ° handler
        switch (request.type) {
            // åˆå§‹åŒ–å’ŒçŠ¶æ€
            case "init":
                return handleInit(request, this.handlerContext);

            case "get_claude_state":
                return handleGetClaudeState(request, this.handlerContext);

            case "get_mcp_servers":
                return handleGetMcpServers(request, this.handlerContext, channelId);

            case "get_asset_uris":
                return handleGetAssetUris(request, this.handlerContext);

            // ç¼–è¾‘å™¨æ“ä½œ
            case "open_file":
                return handleOpenFile(request, this.handlerContext);

            case "get_current_selection":
                return handleGetCurrentSelection(this.handlerContext);

            case "open_diff":
                return handleOpenDiff(request, this.handlerContext, signal);

            case "open_content":
                return handleOpenContent(request, this.handlerContext, signal);

            // UI æ“ä½œ
            case "show_notification":
                return handleShowNotification(request, this.handlerContext);

            case "new_conversation_tab":
                return handleNewConversationTab(request, this.handlerContext);

            case "rename_tab":
                return handleRenameTab(request, this.handlerContext);

            case "open_url":
                return handleOpenURL(request, this.handlerContext);

            // è®¾ç½®
            case "set_permission_mode": {
                if (!channelId) {
                    throw new Error('channelId is required for set_permission_mode');
                }
                const permReq = request as any;
                await this.setPermissionMode(channelId, permReq.mode);
                return {
                    type: "set_permission_mode_response",
                    success: true
                };
            }

            case "set_model": {
                if (!channelId) {
                    throw new Error('channelId is required for set_model');
                }
                const modelReq = request as any;
                const targetModel = modelReq.model?.value ?? "";
                if (!targetModel) {
                    throw new Error("Invalid model selection");
                }
                await this.setModel(channelId, targetModel);
                return {
                    type: "set_model_response",
                    success: true
                };
            }

            case "set_thinking_level": {
                if (!channelId) {
                    throw new Error('channelId is required for set_thinking_level');
                }
                const thinkReq = request as any;
                await this.setThinkingLevel(channelId, thinkReq.thinkingLevel);
                return {
                    type: "set_thinking_level_response"
                };
            }

            case "open_config_file":
                return handleOpenConfigFile(request, this.handlerContext);

            // ä¼šè¯ç®¡ç†
            case "list_sessions_request":
                return handleListSessions(request, this.handlerContext);

            case "get_session_request":
                return handleGetSession(request, this.handlerContext);

            // æ–‡ä»¶æ“ä½œ
            case "list_files_request":
                return handleListFiles(request, this.handlerContext);

            case "stat_path_request":
                return handleStatPath(request as any, this.handlerContext);

            case "write_file":
                return handleWriteFile(request as any, this.handlerContext);

            // è¿›ç¨‹æ“ä½œ
            case "exec":
                return handleExec(request, this.handlerContext);

            // SSH æ“ä½œ
            case "ssh_connect":
                return handleSSHConnect(request as any, this.handlerContext);

            case "ssh_command":
                return handleSSHCommand(request as any, this.handlerContext);

            case "ssh_disconnect":
                return handleSSHDisconnect(request as any, this.handlerContext);

            case "ssh_get_output":
                return handleSSHGetOutput(request as any, this.handlerContext);

            case "ssh_list_sessions":
                return handleSSHListSessions(request as any, this.handlerContext);

            // Claude é…ç½®ç®¡ç†
            case "get_claude_config":
                return handleGetClaudeConfig(request as any, this.handlerContext);

            case "set_api_key":
                return handleSetApiKey(request as any, this.handlerContext);

            case "set_base_url":
                return handleSetBaseUrl(request as any, this.handlerContext);

            case "get_subscription":
                return handleGetSubscription(request as any, this.handlerContext);

            case "get_usage":
                return handleGetUsage(request as any, this.handlerContext);

            case "set_auto_approve_config": {
                const configReq = request as any;
                this.setAutoApproveConfig(configReq.config);
                return {
                    type: "set_auto_approve_config_response",
                    success: true
                };
            }

            // æœ¬åœ° Todo CRUD
            case "get_local_todos":
                return handleGetLocalTodos(request as any, this.handlerContext);

            case "add_local_todo":
                return handleAddLocalTodo(request as any, this.handlerContext);

            case "update_local_todo":
                return handleUpdateLocalTodo(request as any, this.handlerContext);

            case "delete_local_todo":
                return handleDeleteLocalTodo(request as any, this.handlerContext);

            case "clear_completed_todos":
                return handleClearCompletedTodos(request as any, this.handlerContext);

            case "import_claude_todos":
                return handleImportClaudeTodos(request as any, this.handlerContext);

            case "read_task_file":
                return this.handleReadTaskFile();

            // è‡ªåŠ¨ä»»åŠ¡
            case "enable_auto_task":
                return this.handleEnableAutoTask(request as any);

            case "disable_auto_task":
                return this.handleDisableAutoTask();

            case "get_auto_task_config":
                return this.handleGetAutoTaskConfig();

            case "set_auto_task_interval":
                return this.handleSetAutoTaskInterval(request as any);

            case "check_tasks_now":
                return this.handleCheckTasksNow();

            // æ–‡ä»¶æ’¤å›
            case "revert_file_change":
                return this.handleRevertFileChange(request as any);

            // æŸ¥çœ‹å¿«ç…§å·®å¼‚
            case "view_snapshot_diff":
                return this.handleViewSnapshotDiff(request as any);

            // case "open_claude_in_terminal":
            //     return handleOpenClaudeInTerminal(request, this.handlerContext);

            // è®¤è¯
            // case "get_auth_status":
            //     return handleGetAuthStatus(request, this.handlerContext);

            // case "login":
            //     return handleLogin(request, this.handlerContext);

            // case "submit_oauth_code":
            //     return handleSubmitOAuthCode(request, this.handlerContext);

            default:
                throw new Error(`Unknown request type: ${request.type}`);
        }
    }

    /**
     * è¯»å–ä»»åŠ¡æ–‡ä»¶ (.tasks/current.md)
     */
    private async handleReadTaskFile(): Promise<any> {
        try {
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                return {
                    type: "read_task_file_response",
                    success: false,
                    error: "æ²¡æœ‰æ‰“å¼€çš„å·¥ä½œåŒº"
                };
            }

            const taskFilePath = vscode.Uri.joinPath(workspaceFolder.uri, '.tasks', 'current.md');

            try {
                const content = await vscode.workspace.fs.readFile(taskFilePath);
                return {
                    type: "read_task_file_response",
                    success: true,
                    content: Buffer.from(content).toString('utf-8')
                };
            } catch {
                // æ–‡ä»¶ä¸å­˜åœ¨
                return {
                    type: "read_task_file_response",
                    success: false,
                    error: "ä»»åŠ¡æ–‡ä»¶ä¸å­˜åœ¨"
                };
            }
        } catch (error) {
            return {
                type: "read_task_file_response",
                success: false,
                error: String(error)
            };
        }
    }

    /**
     * å¯ç”¨è‡ªåŠ¨ä»»åŠ¡
     */
    private handleEnableAutoTask(request: { interval?: number }): any {
        this.autoTaskService.enable(request.interval);
        return {
            type: "enable_auto_task_response",
            success: true,
            config: this.autoTaskService.getConfig()
        };
    }

    /**
     * ç¦ç”¨è‡ªåŠ¨ä»»åŠ¡
     */
    private handleDisableAutoTask(): any {
        this.autoTaskService.disable();

        // å‘é€é€šçŸ¥åˆ°å‰ç«¯ï¼Œæ¸…é™¤å¾…æ‰§è¡Œä»»åŠ¡
        if (this.transport) {
            this.transport.send({
                type: "request",
                channelId: "auto-task",
                requestId: this.generateId(),
                request: {
                    type: "auto_task_disabled",
                }
            });
            this.logService.info('[ClaudeAgentService] å·²å‘é€è‡ªåŠ¨ä»»åŠ¡ç¦ç”¨é€šçŸ¥');
        }

        return {
            type: "disable_auto_task_response",
            success: true
        };
    }

    /**
     * è·å–è‡ªåŠ¨ä»»åŠ¡é…ç½®
     */
    private handleGetAutoTaskConfig(): any {
        return {
            type: "get_auto_task_config_response",
            config: this.autoTaskService.getConfig()
        };
    }

    /**
     * è®¾ç½®è‡ªåŠ¨ä»»åŠ¡æ£€æŸ¥é—´éš”
     */
    private handleSetAutoTaskInterval(request: { interval: number }): any {
        this.autoTaskService.setCheckInterval(request.interval);
        return {
            type: "set_auto_task_interval_response",
            success: true,
            config: this.autoTaskService.getConfig()
        };
    }

    /**
     * æ‰‹åŠ¨è§¦å‘ä»»åŠ¡æ£€æŸ¥
     */
    private async handleCheckTasksNow(): Promise<any> {
        const tasks = await this.autoTaskService.checkNow();
        return {
            type: "check_tasks_now_response",
            tasks
        };
    }

    /**
     * å¤„ç†æ–‡ä»¶ä¿®æ”¹æ’¤å›è¯·æ±‚
     */
    private async handleRevertFileChange(request: { snapshotId: string }): Promise<any> {
        try {
            const snapshotService = FileSnapshotService.getInstance(this.logService);
            const snapshot = snapshotService.getSnapshot(request.snapshotId);

            if (!snapshot) {
                return {
                    type: "revert_file_change_response",
                    success: false,
                    error: "å¿«ç…§ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ"
                };
            }

            if (!snapshotService.canRevert(request.snapshotId)) {
                return {
                    type: "revert_file_change_response",
                    success: false,
                    error: "æ­¤ä¿®æ”¹å·²è¢«æ’¤å›"
                };
            }

            const success = await snapshotService.revert(request.snapshotId);

            if (success) {
                this.logService.info(`[ClaudeAgentService] æ–‡ä»¶æ’¤å›æˆåŠŸ: ${snapshot.filePath}`);
                return {
                    type: "revert_file_change_response",
                    success: true,
                    filePath: snapshot.filePath
                };
            } else {
                return {
                    type: "revert_file_change_response",
                    success: false,
                    error: "æ’¤å›æ“ä½œå¤±è´¥"
                };
            }
        } catch (error) {
            this.logService.error(`[ClaudeAgentService] æ–‡ä»¶æ’¤å›å¤±è´¥:`, error);
            return {
                type: "revert_file_change_response",
                success: false,
                error: String(error)
            };
        }
    }

    /**
     * å¤„ç†æŸ¥çœ‹å¿«ç…§å·®å¼‚è¯·æ±‚
     * åœ¨ VSCode ä¸­æ‰“å¼€ diff è§†å›¾æ˜¾ç¤ºä¿®æ”¹å‰åçš„å·®å¼‚
     */
    private async handleViewSnapshotDiff(request: { snapshotId: string }): Promise<any> {
        try {
            const snapshotService = FileSnapshotService.getInstance(this.logService);
            const snapshot = snapshotService.getSnapshot(request.snapshotId);

            if (!snapshot) {
                return {
                    type: "view_snapshot_diff_response",
                    success: false,
                    error: "å¿«ç…§ä¸å­˜åœ¨æˆ–å·²è¿‡æœŸ"
                };
            }

            const fileUri = vscode.Uri.file(snapshot.filePath);

            // è¯»å–å½“å‰æ–‡ä»¶å†…å®¹
            let currentContent: string;
            try {
                const currentContentBuffer = await vscode.workspace.fs.readFile(fileUri);
                currentContent = Buffer.from(currentContentBuffer).toString('utf-8');
            } catch {
                // å¦‚æœæ–‡ä»¶ä¸å­˜åœ¨ï¼ˆå¯èƒ½å·²è¢«åˆ é™¤ï¼‰ï¼Œæ˜¾ç¤ºä¸ºç©º
                currentContent = '';
            }

            // åˆ›å»ºä¸´æ—¶æ–‡ä»¶æ¥æ˜¾ç¤ºåŸå§‹å†…å®¹
            const path = await import('path');
            const fileName = path.basename(snapshot.filePath);
            const tempDir = await this.fileSystemService.createTempDir();
            const originalFilePath = path.join(tempDir, `original_${fileName}`);
            const currentFilePath = path.join(tempDir, `current_${fileName}`);

            // å†™å…¥åŸå§‹å†…å®¹å’Œå½“å‰å†…å®¹åˆ°ä¸´æ—¶æ–‡ä»¶
            await vscode.workspace.fs.writeFile(
                vscode.Uri.file(originalFilePath),
                Buffer.from(snapshot.originalContent, 'utf-8')
            );
            await vscode.workspace.fs.writeFile(
                vscode.Uri.file(currentFilePath),
                Buffer.from(currentContent, 'utf-8')
            );

            // æ‰“å¼€ diff è§†å›¾
            const diffTitle = `${fileName} (åŸå§‹ â†” å½“å‰ä¿®æ”¹)`;
            await vscode.commands.executeCommand(
                'vscode.diff',
                vscode.Uri.file(originalFilePath),
                vscode.Uri.file(currentFilePath),
                diffTitle,
                { preview: true }
            );

            this.logService.info(`[ClaudeAgentService] æ‰“å¼€å¿«ç…§å·®å¼‚è§†å›¾: ${snapshot.filePath}`);
            return {
                type: "view_snapshot_diff_response",
                success: true
            };
        } catch (error) {
            this.logService.error(`[ClaudeAgentService] æ‰“å¼€å¿«ç…§å·®å¼‚å¤±è´¥:`, error);
            return {
                type: "view_snapshot_diff_response",
                success: false,
                error: String(error)
            };
        }
    }

    /**
     * å¤„ç†è‡ªåŠ¨ä»»åŠ¡å‘ç°
     */
    private handleAutoTaskFound(tasks: Task[]): void {
        if (!this.transport) {
            this.logService.warn('[ClaudeAgentService] Transport æœªè¿æ¥ï¼Œæ— æ³•å‘é€è‡ªåŠ¨ä»»åŠ¡é€šçŸ¥');
            return;
        }

        const prompt = this.autoTaskService.generateTaskPrompt(tasks);

        // å‘é€é€šçŸ¥åˆ° WebView
        this.transport.send({
            type: "request",
            channelId: "auto-task",
            requestId: this.generateId(),
            request: {
                type: "auto_task_found",
                tasks,
                prompt
            }
        });

        this.logService.info(`[ClaudeAgentService] å‘é€è‡ªåŠ¨ä»»åŠ¡é€šçŸ¥ï¼Œ${tasks.length} ä¸ªä»»åŠ¡`);
    }

    /**
     * å¤„ç†ä»»åŠ¡æ–‡ä»¶å˜åŒ–ï¼ˆç”¨äºå®æ—¶ UI æ›´æ–°ï¼‰
     */
    private handleTaskFileChanged(tasks: Task[]): void {
        if (!this.transport) {
            return;
        }

        // å‘é€æ–‡ä»¶å˜åŒ–é€šçŸ¥åˆ° WebView
        this.transport.send({
            type: "request",
            channelId: "task-file",
            requestId: this.generateId(),
            request: {
                type: "task_file_changed",
                tasks
            }
        });

        this.logService.info(`[ClaudeAgentService] å‘é€ä»»åŠ¡æ–‡ä»¶å˜åŒ–é€šçŸ¥ï¼Œ${tasks.length} ä¸ªä»»åŠ¡`);
    }

    /**
     * å¤„ç†å“åº”
     */
    private handleResponse(message: ResponseMessage): void {
        const handler = this.outstandingRequests.get(message.requestId);
        if (handler) {
            const response = message.response;
            if (typeof response === 'object' && response !== null && 'type' in response && response.type === "error") {
                handler.reject(new Error((response as { error: string }).error));
            } else {
                handler.resolve(response);
            }
            this.outstandingRequests.delete(message.requestId);
        } else {
            this.logService.warn(`[ClaudeAgentService] æ²¡æœ‰æ‰¾åˆ°è¯·æ±‚å¤„ç†å™¨: ${message.requestId}`);
        }
    }

    /**
     * å¤„ç†å–æ¶ˆ
     */
    private handleCancellation(requestId: string): void {
        const abortController = this.abortControllers.get(requestId);
        if (abortController) {
            abortController.abort();
            this.abortControllers.delete(requestId);
        }
    }

    /**
     * å‘é€è¯·æ±‚åˆ°å®¢æˆ·ç«¯
     */
    protected sendRequest<TRequest extends ExtensionRequest, TResponse>(
        channelId: string,
        request: TRequest
    ): Promise<TResponse> {
        const requestId = this.generateId();

        return new Promise<TResponse>((resolve, reject) => {
            // æ³¨å†Œ Promise handlers
            this.outstandingRequests.set(requestId, { resolve, reject });

            // å‘é€è¯·æ±‚
            this.transport!.send({
                type: "request",
                channelId,
                requestId,
                request
            } as RequestMessage);
        }).finally(() => {
            // æ¸…ç†
            this.outstandingRequests.delete(requestId);
        });
    }

    /**
     * è¯·æ±‚å·¥å…·æƒé™
     */
    protected async requestToolPermission(
        channelId: string,
        toolName: string,
        inputs: Record<string, unknown>,
        suggestions: PermissionUpdate[]
    ): Promise<PermissionResult> {
        const request: ToolPermissionRequest = {
            type: "tool_permission_request",
            toolName,
            inputs,
            suggestions
        };

        const response = await this.sendRequest<ToolPermissionRequest, ToolPermissionResponse>(
            channelId,
            request
        );

        return response.result;
    }

    /**
     * å…³é—­æœåŠ¡
     */
    async shutdown(): Promise<void> {
        await this.closeAllChannels();
        this.fromClientStream.done();
    }

    /**
     * é€šçŸ¥å·¥ä½œåŒºå˜åŒ–
     */
    notifyWorkspaceChanged(): void {
        if (!this.transport) {
            return;
        }

        const defaultCwd = this.workspaceService.getDefaultCwd();
        const workspaceFolders = this.workspaceService.getWorkspaceFolderInfos();

        this.logService.info(`[ClaudeAgentService] å·¥ä½œåŒºå˜åŒ–: ${defaultCwd}`);

        // å‘é€å·¥ä½œåŒºå˜åŒ–é€šçŸ¥åˆ° WebView
        this.transport.send({
            type: "request",
            requestId: this.generateId(),
            request: {
                type: "workspace_changed",
                defaultCwd,
                workspaceFolders
            }
        });
    }

    // ========================================================================
    // å·¥å…·æ–¹æ³•
    // ========================================================================

    /**
     * ç”Ÿæˆå”¯ä¸€ ID
     */
    private generateId(): string {
        return Math.random().toString(36).substring(2, 15);
    }

    /**
     * è·å–å½“å‰å·¥ä½œç›®å½•
     */
    private getCwd(): string {
        return this.workspaceService.getDefaultWorkspaceFolder()?.uri.fsPath || process.cwd();
    }

    /**
     * è·å– maxThinkingTokensï¼ˆæ ¹æ® thinking levelï¼‰
     */
    private getMaxThinkingTokens(level: string): number {
        return level === 'off' ? 0 : 31999;
    }

    /**
     * è®¾ç½® thinking level
     */
    async setThinkingLevel(channelId: string, level: string): Promise<void> {
        this.thinkingLevel = level;

        // æ›´æ–°æ­£åœ¨è¿è¡Œçš„ channel
        const channel = this.channels.get(channelId);
        if (channel?.query) {
            const maxTokens = this.getMaxThinkingTokens(level);
            await channel.query.setMaxThinkingTokens(maxTokens);
            this.logService.info(`[setThinkingLevel] Updated channel ${channelId} to ${level} (${maxTokens} tokens)`);
        }
    }

    /**
     * è®¾ç½®æƒé™æ¨¡å¼
     */
    async setPermissionMode(channelId: string, mode: PermissionMode): Promise<void> {
        const channel = this.channels.get(channelId);
        if (!channel) {
            this.logService.warn(`[setPermissionMode] Channel ${channelId} not found`);
            throw new Error(`Channel ${channelId} not found`);
        }

        // æ›´æ–°æœ¬åœ°æƒé™æ¨¡å¼è®°å½•ï¼ˆç”¨äº YOLO æ¨¡å¼åˆ¤æ–­ï¼‰
        this.channelPermissionModes.set(channelId, mode);

        // é‡è¦ï¼šå§‹ç»ˆå‘ SDK ä¼ é€’ 'default' æ¨¡å¼
        // è¿™æ · SDK ä¼šæŒç»­è°ƒç”¨ canUseTool å›è°ƒï¼Œæˆ‘ä»¬åœ¨å›è°ƒä¸­æ ¹æ®æœ¬åœ°è®°å½•çš„æ¨¡å¼è¿›è¡Œåˆ¤æ–­
        // å¦‚æœä¼ é€’ 'acceptEdits'ï¼ŒSDK ä¼šå†…éƒ¨è‡ªåŠ¨å…è®¸ç¼–è¾‘æ“ä½œï¼Œä¸è°ƒç”¨ canUseTool
        // æˆ‘ä»¬éœ€è¦ canUseTool è¢«è°ƒç”¨ï¼Œä»¥ä¾¿å®ç°è‡ªå®šä¹‰çš„ç¡®è®¤é€»è¾‘ï¼ˆå¦‚ Write/Edit ç¡®è®¤ï¼‰
        await channel.query.setPermissionMode('default');
        this.logService.info(`[setPermissionMode] Set channel ${channelId} to mode: ${mode} (SDK always uses 'default' for canUseTool callback)`);
    }

    /**
     * è®¾ç½®æ¨¡å‹
     */
    async setModel(channelId: string, model: string): Promise<void> {
        this.logService.info(`[setModel] æ”¶åˆ°æ¨¡å‹åˆ‡æ¢è¯·æ±‚: channelId=${channelId}, model=${model}`);

        const channel = this.channels.get(channelId);
        if (!channel) {
            this.logService.warn(`[setModel] Channel ${channelId} not found`);
            throw new Error(`Channel ${channelId} not found`);
        }

        // æ¨¡å‹åç§°æ˜ å°„ï¼šå°† UI æ¨¡å‹ ID è½¬æ¢ä¸º API å…¼å®¹æ ¼å¼
        const mappedModel = MODEL_NAME_MAPPING[model] || model;
        if (MODEL_NAME_MAPPING[model]) {
            this.logService.info(`[setModel] æ¨¡å‹åç§°æ˜ å°„: ${model} -> ${mappedModel}`);
        }

        // è®¾ç½®æ¨¡å‹åˆ° channel
        this.logService.info(`[setModel] è°ƒç”¨ channel.query.setModel(${mappedModel})`);
        await channel.query.setModel(mappedModel);

        // ä¿å­˜åˆ°é…ç½®ï¼ˆä¿å­˜åŸå§‹æ¨¡å‹ IDï¼Œä»¥ä¾¿ UI æ˜¾ç¤ºï¼‰
        await this.configService.updateValue('xiong.selectedModel', model);

        this.logService.info(`[setModel] æ¨¡å‹åˆ‡æ¢å®Œæˆ: channel=${channelId}, model=${model}`);
    }

    /**
     * è®¾ç½®è‡ªåŠ¨å®¡æ‰¹é…ç½®
     */
    setAutoApproveConfig(config: { autoApproveEnabled?: boolean; confirmWrite?: boolean; confirmEdit?: boolean }): void {
        if (typeof config.autoApproveEnabled === 'boolean') {
            this.autoApproveConfig.autoApproveEnabled = config.autoApproveEnabled;
        }
        if (typeof config.confirmWrite === 'boolean') {
            this.autoApproveConfig.confirmWrite = config.confirmWrite;
        }
        if (typeof config.confirmEdit === 'boolean') {
            this.autoApproveConfig.confirmEdit = config.confirmEdit;
        }
        this.logService.info(`[setAutoApproveConfig] æ›´æ–°é…ç½®: autoApproveEnabled=${this.autoApproveConfig.autoApproveEnabled}, confirmWrite=${this.autoApproveConfig.confirmWrite}, confirmEdit=${this.autoApproveConfig.confirmEdit}`);
    }

    /**
     * åˆ¤æ–­å·¥å…·æ˜¯å¦éœ€è¦ç”¨æˆ·ç¡®è®¤
     *
     * @param toolName å·¥å…·åç§°
     * @returns æ˜¯å¦éœ€è¦ç¡®è®¤
     */
    private shouldConfirmTool(toolName: string): boolean {
        // å¦‚æœæ€»å¼€å…³å…³é—­ï¼Œæ‰€æœ‰å·¥å…·éƒ½éœ€è¦ç¡®è®¤
        if (!this.autoApproveConfig.autoApproveEnabled) {
            this.logService.info(`[shouldConfirmTool] æ€»å¼€å…³å…³é—­ï¼Œ${toolName} éœ€è¦ç¡®è®¤`);
            return true;
        }

        // file_write å·¥å…· (å†™å…¥æ–‡ä»¶)
        if (toolName === 'file_write' && this.autoApproveConfig.confirmWrite) {
            this.logService.info(`[shouldConfirmTool] file_write éœ€è¦ç¡®è®¤ (confirmWrite=true)`);
            return true;
        }

        // file_edit å·¥å…· (ç¼–è¾‘æ–‡ä»¶)
        if (toolName === 'file_edit' && this.autoApproveConfig.confirmEdit) {
            this.logService.info(`[shouldConfirmTool] file_edit éœ€è¦ç¡®è®¤ (confirmEdit=true)`);
            return true;
        }

        this.logService.debug(`[shouldConfirmTool] ${toolName} ä¸éœ€è¦ç¡®è®¤`);
        // å…¶ä»–å·¥å…·é»˜è®¤ä¸éœ€è¦ç¡®è®¤
        return false;
    }
}
